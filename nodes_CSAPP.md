# 第七章 链接

## 基础定义

链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程。可执行于编译时、加载时、甚至运行时。

链接器使得在软件开发过程中不同模块可以分离编译，独立修改和编译这些模块。

### 静态链接

链接器需要完成两个主要任务：符号解析和重定位。

符号解析：将每个符号引用与一个符号定义关联起来。

重定位：编译器和汇编器生成从地址0开始的代码和数据节。重定位是链接器把每个符号定义与一个内存位置关联起来，从而重定位这些节。

### 目标文件

可重定位目标文件：包含二进制代码和数据，可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。

可执行目标文件：包含二进制代码和数据，可以被直接复制到内存并执行。

共享目标文件：一种特殊可重定位目标文件，可以在加载或者运行时被动态的加载进内存并链接。

编译器和汇编器生成可重定位目标文件（共享目标文件）；链接器生成可执行目标文件。

### 可重定位目标文件



### 符号和符号表

每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。

符号分为三类：由**模块m定义**并**可以被其他模块引用**的全局符号；由**其他模块定义**并被模块m引用的全局符号；只**被模块m定义和引用**的局部符号。

在 **C** 中，源 文件扮演模块的角色。任何带有**static** 属性声明的全局变量或者函数都是模块私有的。类似地，任何不带 **static** 属性声明的全局变量和函数都是公共的，可以被其他模块访问。

### 符号解析

链接器解析符号引用的方法是将**每个引用**与它**输入的可重定位目标文件的符号表中的一个确定的符号**定义关联起来。

对全局符号的引用解析就棘手得多。当编译器遇到一个不是在当前模块中定义 的符号(变量或函数名）时，会假设该符号是在其他某个模块中定义，生成一个链接器符 号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引 用符号的定义，就输出一条(通常很难阅读的）错误信息并终止。

#### **链接器如何解析多重定义的全局符号？**

在编译时，编译器向汇编器输出每个全局符号，或者是强（strong)或者是弱（weak)，汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。**函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。**

根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名。

\* 规则 1: **不允许**有多个同名的强符号。

\* 规则 2: 如果有**一个强符号和多个弱符号同名**，那么**选择强符号**。

\* 规则 3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。

#### 与静态库链接

静态库概念被提出来，以解决这些不同方法的缺点。相关的函数可以被编译为独立的 目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定 单独的文件名字来使用这些在库中定义的函数。





### 库打桩机制

Linux 链接器支持一个很强大的技术，称为库打桩（library interpositioning), 它允许你截获对共享库函数的调用，取而代之执行自己的代码。

给定一个需要打桩的目标函数，创建一个包装函数，它的原型与目标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。



# 第八章 异常控制流

## 异常

|      |                    |      |                                |
| ---- | ------------------ | ---- | ------------------------------ |
| 中断 | 来自IO设备的信号   | 异步 | 总是返回到下一条指令           |
| 陷阱 | 有意的异常         | 同步 | 总是返回到下一条指令           |
| 故障 | 潜在的可恢复的错误 | 同步 | 可能返回到当前指令；也可能终止 |
| 终止 | 不可恢复的错误     | 同步 | 不会返回                       |

## 进程

进程的经典定义就是**一个执行中程序的实例**。系统中的每个程序都运行在某个进程的上下文(context)中。**上下文是由程序正确运行所需的状态组成的**。

程序计数器（PC），PC值得序列叫做逻辑控制流、逻辑流。

并发流：一个逻辑流的执行在时间上与另一个流重叠，这说明这两个流为并发流，并发地运行。

多个流并发地执行的一般现象被称为并发（concurrency)。

一个进程和其他进程轮流运行的概念称为多任务（multitasking)。

进程为每一个程序提供它自己的私有地址空间。同时为了使进程可以正常安全运行，处理器通过模式位来判断进程处于内核模式还是用户模式。

内核为每个进程维持一个上下文（context)。上下文就是内核重新启动一个被抢占的进程所需的状态。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度（scheduling)。当内核选择一个新的进程运行时，我们说内核调度了这个进程。

上下文切换： 1)保存当前进程的上下文，2)恢复某个先前被抢占的进程被保存的上下文，3)将控制传递给这个新恢复的进程。

## 进程控制

每个进程都有一个唯一的正数(非零)进程 ID(PID)

进程总是处于三种状态：运行、停止、终止。运行是指正在运行或者在等待被执行且最终会被调度。停止是指执行被挂起且不会被调度。终止是指进程永远的停止。









