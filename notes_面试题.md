# C++

## 智能指针

智能指针原理与简单实现 https://blog.csdn.net/xiaoyaolangwj/article/details/129612435

### unique_ptr

同⼀时刻只能有⼀个 unique_ptr 指向给定对象，离开作⽤域时，若其指向对象，则自动将其所指对象销毁（默认delete）。 

实现了运算符 `*` 和 `->` 运算符的重载。

```cpp
//构建unique_ptr方式1，需要delete 原始指针
Cat *c_p2 = new Cat("yz");
std::unique_ptr<Cat> u_c_p2{c_p2};
delete c_p2;
c_p2 = nullptr;
u_c_p2->cat_info();

//构建unique_ptr方式2
std::unique_ptr<Cat> u_c_p3{new Cat("dd")};
u_c_p3->cat_info();
u_c_p3->set_cat_name("oo");
u_c_p3->cat_info();

//构建unique_ptr方式3
std::unique_ptr<Cat>u_c_p4 = make_unique<Cat>();
u_c_p4->set_cat_name("oo");
u_c_p4->cat_info();

```

## RAII



## 指针与引用

指针存放某个对象的地址，其本⾝就是变量（命了名的对象），本⾝就有地址，所以可以有指向指针的指针；可变，包括其所**指向的地址**的改变和**其指向的地址中所存放的数据**的改变。

引⽤就是变量的别名，从⼀⽽终，不可变，在创建时必须初始化。

C++ 引用 vs 指针，有三个主要的不同：

- 不存在空引用。引用必须连接到一块合法的内存。但是存在指向空值的指针
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。

## 值传递、地址传递、引用传递

首先说明的是，参数传递的本质是函数调用栈的参数的copy。

- 值传递：形参是实参的一份临时拷贝，形参和实参分别占不同的地址，对形参的修改不会影响实参。
- 地址传递：传址调用是把函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式。这种传参方式可以让函数和函数外边的变量建立起正真的联系，也就是函数内部可以直接操作函数外部的变量。
- 引用传递：引用相当于给参数取”别名“，两者占用同一个地址，修改”别名“，也会修改原有的参数。

## 字节流





### 强制类型转换



## 关键字

### const

#### 修饰常量

被const修饰的必须是只读变量，定义时必须初始化。

常量指针：指向常量的指针，被指对象不能通过指针来修改，但是该指针可以指向其他变量。

指针常量：指针为常量。指针本身在定义的时候初始化，并且不能被改变，不能指向别的变量。但是该指针指向的对象的指可以通过该指针来修改。

#### 修饰类成员变量

- 只在某个对象的生命周期内是常量，而对该类实例化的全部对象而言是可变的
- 不能赋值，不能在类外定义;
- 只能通过==构造函数的参数初始化列表初始化==[原因:因为不同的对象对其const数据成员的值可以不同，所以不能在类中声明时初始化]

#### 修饰类成员函数

- 防止成员函数修改对象的内容[不能修改成员变量的值，但是可以访问]
- const对象不可以调用非const的函数:但是非const对象可以调用;



### static

#### 修饰常量

函数执行结束之后并不会释放对应的内存

#### 修饰类成员变量

*  所有对象共享同一份数据
*  在编译阶段分配内存
*  类内声明，类外初始化

#### 修饰类成员函数

*  所有对象共享同一个函数
*  静态成员函数只能访问static静态成员变量

### new/delete 与 malloc/free

![image-20230423170635694](.\asset\new_malloc.png)



### extern

定义：声明外部变量【在函数或者⽂件外部定义的全局变量】

### 前置++ 与 后置++

```cpp
struct Test
{
    int m_i;
    //前置++
    Test & operator++()
    {
        ++(this->m_i);
        return *this;
    }
    //后置++
    const Test operator(int)
    {
        Test t = *this;
        ++(*this);
        return t;
    }
};
```

#### 后置++

- 先取值，再增加；
- a++并不是原子操作，因为这一条语句涉及三条机器指令，所以是线程不安全的
- 为了区分前后置，==重载函数是以参数类型来区分==，在调⽤的时候，编译器默默给int指定为⼀个0

#### 前置++

- 先增加，再取值
- 前置++为了可以连续运算，所以会返回对象的引用；
- 后置++会产生临时对象，所以我们最好在满足意图的情况下，优先使用前置++;



## 类

### OOP三大特性

#### 封装：

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态

```cpp
class Person
{
private://数据私有
   string bame;
   int num;
public://方法公有
    void getName()
    {
        return name;
    }
};
```

#### 继承：

继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。 继承的作用：避免公用代码的重复开发，减少代码和数据冗余。

```cpp
#include <iostream>
 
using namespace std;
class Base
{
public:
    void printBase(void)
    {
        cout<<"Base中的printBase"<<endl;
    }
};
class Son:public Base
{
 
};
int main(int argc, char *argv[])
{
    Son ob;
    ob.printBase();
    return 0;
}
```

继承方式：

![img](.\asset\clip_image002.png)



继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反



#### 多态：

一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口。

多态分为两类

* 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名
* 动态多态: 派生类和虚函数实现运行时多态

静态多态和动态多态区别：

* 静态多态的函数地址早绑定  -  编译阶段确定函数地址
* 动态多态的函数地址晚绑定  -  运行阶段确定函数地址

多态满足条件

* 有继承关系
* 子类重写父类中的虚函数

多态使用条件

* 父类指针或引用指向子类对象

### 虚继承：用来解决菱形继承

菱形继承是一种错误。可以利用虚继承解决变量二义性。



### 动态多态：虚函数，虚函数表

主要是涉及到多态的底层实现原理，[多态的底层原理（C++程序员Must掌握）](https://blog.csdn.net/xiaoyaolangwj/article/details/122615037)

动态多态：

当父类指针或者引用指向不同的子类对象时，比如指向Cat或者指向Dog的对象。那么就会动态（碰到哪个子类，就去找哪个子类）去寻找这两个子类的虚函数，如果没有，那就直接执行继承的虚函数。如果有，就多态（每个子类都有不同的继承和重写）的执行各自类别的重写的虚函数。

实现方式：虚函数表指针。

这个指针，指向虚函数表：虚函数表中存储的是虚函数的函数入口地址。子类会继承这个虚函数表指针，如果子类重写了这个虚函数，那么子类的虚函数表指针就会指向新的虚函数入口地址。（虚函数表指针指向的变更。）



### 虚析构和纯虚析构

虚析构和纯虚析构：用来解决在多态场景下，delete父类指针之后，子类的析构函数无法调用，如果子类在堆区开辟了内存，则无法在析构函数中对内存释放，造成堆区内存泄露。可以将父类的析构函数设置为虚析构或纯虚析构函数，从而可以调用子类的虚构函数。参考资料：https://blog.csdn.net/xiaoyaolangwj/article/details/122690310



### 深拷贝与浅拷贝

深浅拷贝是面试经典问题，也是常见的一个坑

浅拷贝：简单的赋值拷贝操作，指向同一个内存空间。

深拷贝：在堆区重新申请空间，进行拷贝操作，分别是两块独立的内存空间。

对于类的构造函数，编译器默认提供的是浅拷贝构造函数。但是当存在类中的成员函数需要在堆中申请内存（new）的时候，需要自己重写深拷贝的拷贝构造函数，避免在析构函数中重复释放内存（delete）。



### 静态成员

==只有非静态成员变量会存储在类内，当作类的大小。成员函数和成员变量分开存储。==

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

*  静态成员变量
   *  所有对象共享同一份数据
   *  在编译阶段分配内存
   *  ==类内声明，类外初始化==
*  静态成员函数
   *  所有对象共享同一个函数
   *  ==静态成员函数只能访问静态成员变量==



1. STL：unordered_map；unordered_set



# 操作系统

## 内存泄露、雪崩、击穿





# 计网

1. TCP三次握手 四次挥手





# 数据库



